<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIA Navigator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #E5E7EB; /* text-gray-200 */
        }
        .card {
            background-color: #1F2937; /* bg-gray-800 */
            border-width: 2px;
            border-style: solid;
            transition: all 0.3s ease-in-out;
            min-height: 150px;
        }
        .card-resolution { border-color: #1D4ED8; } /* Blue */
        .card-tension { border-color: #BE123C; } /* Rose */
        .card-out-of-key { 
            border-color: #F59E0B; /* border-amber-500 */
        }
        
        .badge {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.75em;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .badge:hover { transform: scale(1.05); }

        .badge-resolution { background-color: #1D4ED8; color: #EFF6FF; }
        .badge-tension { background-color: #BE123C; color: #FFE4E6; }
        .badge-out-of-key { background-color: #B45309; color: #FEF3C7; }
        
        .target-choice-label {
            display: block;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            background-color: rgba(71, 85, 105, 0.2);
            border: 1px solid #4B5563;
            transition: all 0.2s;
        }
        .target-choice-label:hover {
            background-color: rgba(71, 85, 105, 0.5);
            border-color: #6B7280;
        }
        .target-choice-input:checked + .target-choice-label {
            background-color: #4c1d95;
            border-color: #a78bfa;
            color: white;
        }
        .target-choice-input {
            display: none;
        }
        
        .input-grid-cell {
            background-color: #111827;
            border: 1px solid #4B5563;
            border-radius: 0.5rem;
            width: 100%;
            padding: 0.25rem;
            text-align: center;
            font-size: 0.875rem;
            font-weight: bold;
            color: white;
            transition: all 0.2s;
        }
        .input-grid-cell:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        .input-grid-cell.cell-active {
            box-shadow: 0 0 0 3px #3B82F6;
            border-color: #3B82F6;
        }

        .scale-notes-block {
            background-color: #374151;
            padding: 0.25rem 0.75rem;
            border-radius: 6px;
            font-weight: 600;
            color: #D1D5DB;
            display: flex;
            gap: 0.75rem;
            font-size: 0.9em;
        }
        .scale-notes-block .root {
            color: #60A5FA; /* blue-400 */
            font-weight: 800;
        }
        
        #info-modal-overlay { transition: opacity 0.3s ease-in-out; }
        #info-modal-content { transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; }
        
        /* Styles pour le manche de guitare */
        #guitar-neck-wrapper {
            overflow-x: auto;
            padding-bottom: 10px;
            display: flex;
            justify-content: center;
        }
        .note-dot {
            transition: all 0.2s;
            stroke-width: 2;
        }
        @keyframes pulse-note {
            0% { r: 9; opacity: 1; }
            50% { r: 11; opacity: 0.8; }
            100% { r: 9; opacity: 1; }
        }
        .note-dot-active {
            animation: pulse-note 1s infinite;
        }

    </style>
</head>
<body class="p-2 sm:p-4">

    <div class="min-h-screen flex flex-col items-center">
        
        <div class="w-full max-w-7xl mx-auto">

            <!-- Header -->
            <header class="text-center mb-2">
                <h1 class="text-3xl md:text-4xl font-extrabold text-white mb-1">üé∏ GIA Navigator</h1>
                <p class="text-md text-gray-400">Votre plan d'action visuel pour l'improvisation.</p>
            </header>

            <!-- Input & Player Section -->
            <div class="mb-2 p-3 bg-gray-800/50 rounded-xl border border-gray-700">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-lg font-bold text-white">1. Entrez votre grille (1 case = 2 temps)</h2>
                    <div class="flex gap-2">
                        <button id="random-grid-btn" title="G√©n√©rer une grille al√©atoire" class="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-1 px-3 rounded-lg transition">üé≤ Al√©atoire</button>
                        <button id="clear-grid-btn" title="Vider la grille" class="text-xs bg-red-800/50 hover:bg-red-700 text-white font-semibold py-1 px-3 rounded-lg transition">üóëÔ∏è Vider</button>
                    </div>
                </div>
                <div id="input-grid" class="grid grid-cols-8 gap-1 mb-3">
                    <!-- 24 input cells will be generated by JS -->
                </div>
                 <!-- Guitar Neck Section -->
                <div id="guitar-neck-wrapper">
                    <svg id="guitar-neck-svg" width="850" height="150"></svg>
                </div>
                <!-- Player Controls -->
                <div class="mt-3 flex flex-col sm:flex-row items-center justify-center gap-4 p-2 bg-gray-900/50 rounded-lg">
                    <button id="play-stop-btn" class="w-full sm:w-auto bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 flex items-center justify-center gap-2">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <svg id="stop-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span id="play-btn-text" class="w-16 text-left">Play</span>
                    </button>
                    <div class="flex items-center gap-2 w-full sm:w-auto">
                        <label for="tempo-slider" class="font-semibold text-gray-300">Tempo:</label>
                        <input type="range" id="tempo-slider" min="45" max="180" value="45" class="w-full">
                        <span id="tempo-value" class="font-bold text-white w-12 text-center">45 bpm</span>
                    </div>
                </div>
            </div>


            <!-- Analysis Section -->
            <div class="p-3 bg-gray-800/50 rounded-xl border border-gray-700">
                <div class="flex flex-col sm:flex-row justify-between sm:items-start mb-2 gap-3">
                    <div>
                        <h2 class="text-lg font-bold text-white">2. Votre Plan d'Action GIA</h2>
                        <div class="flex items-center flex-wrap gap-x-4 gap-y-2 mt-2">
                             <p id="tonality-display" class="text-blue-300 font-semibold"></p>
                             <div id="scale-notes-display"></div>
                        </div>
                    </div>
                    <div class="flex flex-col items-end gap-2 self-stretch">
                         <button id="export-btn" class="hidden w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                             Exporter (CSV)
                         </button>
                    </div>
                </div>
                <div id="analysis-output" class="flex flex-wrap -m-1">
                    <!-- Analysis cards will be injected here -->
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center mt-4 text-gray-500 text-sm">
                <p>D√©velopp√© pour la Guitare Impro Acad√©mie par Fran√ßois.</p>
            </footer>
        </div>
    </div>
    
    <!-- Info Modal -->
    <div id="info-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div id="info-modal-overlay" class="absolute inset-0"></div>
        <div id="info-modal-content" class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md z-10 transform scale-95 opacity-0">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-xl font-bold text-white"></h3>
                <button id="modal-close-btn" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <p id="modal-body" class="text-gray-300"></p>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const inputGrid = document.getElementById('input-grid');
        const tonalityDisplay = document.getElementById('tonality-display');
        const scaleNotesDisplay = document.getElementById('scale-notes-display');
        const analysisOutput = document.getElementById('analysis-output');
        const exportBtn = document.getElementById('export-btn');
        const modal = document.getElementById('info-modal');
        const modalOverlay = document.getElementById('info-modal-overlay');
        const modalContent = document.getElementById('info-modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const playStopBtn = document.getElementById('play-stop-btn');
        const playBtnText = document.getElementById('play-btn-text');
        const playIcon = document.getElementById('play-icon');
        const stopIcon = document.getElementById('stop-icon');
        const tempoSlider = document.getElementById('tempo-slider');
        const tempoValue = document.getElementById('tempo-value');
        const clearGridBtn = document.getElementById('clear-grid-btn');
        const randomGridBtn = document.getElementById('random-grid-btn');
        const neckSVG = document.getElementById('guitar-neck-svg');

        // --- Music Theory Data ---
        const NOTES = {
            sharp: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            flat:  ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
        };
        const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
        const MINOR_PENTATONIC_INTERVALS = [0, 3, 5, 7, 10];
        const MAJOR_PENTATONIC_INTERVALS = [0, 2, 4, 7, 9];
        
        let analysisResultsForExport = [];
        let bassSynth, part, metronome, countdownPart;
        let currentLoopEndMeasures = 0;
        const TOTAL_CELLS = 24;
        
        const TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
        let notePositions = {};

        // --- Initialization & Event Listeners ---
        function initializeApp() {
            calculateNotePositions();
            drawNeck();
            initializeGrid();
            initializePlayer();
            exportBtn.addEventListener('click', exportToCSV);
            clearGridBtn.addEventListener('click', clearGrid);
            randomGridBtn.addEventListener('click', generateRandomProgression);
            analysisOutput.addEventListener('change', handleNoteSelection);
            analysisOutput.addEventListener('click', handleBadgeClick);
            modalOverlay.addEventListener('click', hideModal);
            modalCloseBtn.addEventListener('click', hideModal);
        }

        function initializeGrid() {
            for(let i=0; i < TOTAL_CELLS; i++) {
                const cell = document.createElement('input');
                cell.type = 'text';
                cell.className = 'input-grid-cell';
                cell.setAttribute('aria-label', `Accord ${i+1}`);
                cell.addEventListener('input', () => {
                    analyzeProgression();
                    updatePlayer();
                });
                inputGrid.appendChild(cell);
            }
        }
        
        function initializePlayer() {
            bassSynth = new Tone.MonoSynth({
                oscillator: { type: 'fatsawtooth' },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 },
                filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.8, baseFrequency: 200, octaves: 4 }
            }).toDestination();
            bassSynth.volume.value = -6;

            metronome = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 10,
                oscillator: { type: 'square' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
            }).toDestination();
            metronome.volume.value = -12;

            playStopBtn.addEventListener('click', async () => {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }
                
                if (Tone.Transport.state === 'started') {
                    stopPlayback();
                } else {
                    updatePlayer();
                    startWithCountdown();
                }
            });

            tempoSlider.addEventListener('input', (e) => {
                const bpm = e.target.value;
                Tone.Transport.bpm.value = bpm;
                tempoValue.textContent = `${bpm} bpm`;
            });
            Tone.Transport.bpm.value = tempoSlider.value;
            tempoValue.textContent = `${tempoSlider.value} bpm`;
        }

        function startWithCountdown() {
            if (currentLoopEndMeasures === 0) return;

            const firstChordAnalysis = analysisResultsForExport[0];
            if (firstChordAnalysis) {
                const activeNotes = (firstChordAnalysis.selectedNote) ? [firstChordAnalysis.selectedNote] : [];
                
                let nextChordAnalysis = analysisResultsForExport[1] || firstChordAnalysis;
                const previewNotes = (nextChordAnalysis && nextChordAnalysis.selectedNote) ? [nextChordAnalysis.selectedNote] : [];

                updateNeckDisplay({ active: activeNotes, preview: previewNotes });
            }

            playBtnText.textContent = '...';
            playStopBtn.disabled = true;

            const countdownEvents = [
                { time: '0:0', count: 4 }, { time: '0:1', count: 3 },
                { time: '0:2', count: 2 }, { time: '0:3', count: 1 }
            ];

            if(countdownPart) countdownPart.dispose();
            countdownPart = new Tone.Part((time, value) => {
                metronome.triggerAttackRelease('C5', '8n', time);
                Tone.Draw.schedule(() => {
                    playBtnText.textContent = value.count;
                }, time);
            }, countdownEvents).start(0);
            
            countdownPart.loop = false;
            
            Tone.Transport.scheduleOnce(() => {
                playBtnText.textContent = 'Stop';
                playIcon.classList.add('hidden');
                stopIcon.classList.remove('hidden');
                playStopBtn.disabled = false;
            }, '1m'); 

            Tone.Transport.loop = true;
            Tone.Transport.loopStart = '1m';
            Tone.Transport.loopEnd = `${currentLoopEndMeasures + 1}m`;

            Tone.Transport.start();
        }

        function stopPlayback() {
             if (countdownPart) {
                 countdownPart.stop(0);
                 countdownPart.dispose();
                 countdownPart = null;
             }
             if (part) {
                 part.stop(0);
                 part.dispose();
                 part = null;
             }
             
             bassSynth.triggerRelease();

             Tone.Transport.stop();
             Tone.Transport.cancel(0);
             
             Tone.Transport.position = 0;

             Tone.Transport.loop = false;
             Tone.Transport.loopStart = 0;
             
             playBtnText.textContent = 'Play';
             playIcon.classList.remove('hidden');
             stopIcon.classList.add('hidden');
             playStopBtn.disabled = false;
             document.querySelectorAll('.input-grid-cell.cell-active').forEach(c => c.classList.remove('cell-active'));
             updateNeckDisplay({ active: [], preview: [] });
        }
        
        // --- Core Functions ---
        function analyzeProgression() {
            const inputs = Array.from(document.querySelectorAll('#input-grid input'));
            const chords = inputs.map(input => input.value.trim());
            const firstChord = chords.find(c => c);

            analysisOutput.innerHTML = '';
            
            if (!firstChord) {
                tonalityDisplay.textContent = 'En attente d\'un accord...';
                scaleNotesDisplay.innerHTML = '';
                exportBtn.classList.add('hidden');
                drawNeck(); // Redraw empty neck
                return;
            }

            analysisResultsForExport = [];
            const key = detectKey(firstChord);
            tonalityDisplay.textContent = `Tonalit√©: ${key.name}`;
            displayScaleNotes(key);
            
            const pentatonicNotes = getPentatonicScaleNotes(key);
            drawNeck(pentatonicNotes);

            const activeChordsWithIndices = [];
            chords.forEach((chord, index) => {
                if (chord.trim() !== '') {
                    activeChordsWithIndices.push({ chord, index });
                }
            });
            
            if (activeChordsWithIndices.length > 0) {
                activeChordsWithIndices.forEach((chordItem, activeIndex) => {
                    const nextChordItem = activeChordsWithIndices[activeIndex + 1] || activeChordsWithIndices[0];
                    const analysis = analyzeSingleChord(chordItem.chord, key, nextChordItem.chord);
                    analysis.gridIndex = chordItem.index;
                    analysis.analysisIndex = activeIndex;
                    analysisResultsForExport.push(analysis);
                    analysisOutput.appendChild(createAnalysisCard(analysis));
                });
                exportBtn.classList.remove('hidden');
            } else {
                exportBtn.classList.add('hidden');
            }
        }

        function updatePlayer() {
            if (part) part.dispose();

            const inputs = Array.from(document.querySelectorAll('#input-grid input'));
            const chords = inputs.map(input => input.value.trim());
            const lastChordIndex = findLastIndex(chords, c => c);
            
            if (lastChordIndex === -1) {
                currentLoopEndMeasures = 0;
                return;
            }

            const totalBeatsInProgression = (lastChordIndex + 1) * 2;
            const loopEndMeasures = Math.ceil(totalBeatsInProgression / 4);
            currentLoopEndMeasures = loopEndMeasures;
            const totalLoopBeats = loopEndMeasures * 4;
            const events = [];

            for (let i = 0; i <= lastChordIndex; i++) {
                const chordName = chords[i];
                if (chordName) {
                    const beat = i * 2;
                    const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
                    const rootNote = getNoteInfo(chordName).root;

                    if (rootNote !== '?') {
                        let nextChangeIndex = -1;
                        for (let j = i + 1; j <= lastChordIndex; j++) {
                            if (chords[j]) {
                                nextChangeIndex = j;
                                break;
                            }
                        }
                        
                        const endTimeBeats = (nextChangeIndex !== -1) ? nextChangeIndex * 2 : totalLoopBeats;
                        const durationBeats = endTimeBeats - beat;
                        
                        if (durationBeats > 0) {
                            const durationNotation = `${Math.floor(durationBeats / 4)}:${durationBeats % 4}:0`;
                            events.push({ time, note: rootNote + '2', duration: durationNotation, type: 'bass' });
                        }
                    }
                }
            }
            
            const loopEndCells = currentLoopEndMeasures * 2;
            for (let i = 0; i < loopEndCells; i++) {
                const beat = i * 2;
                const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
                events.push({ time, gridIndex: i, type: 'highlight' });
            }

            for (let beat = 0; beat < totalLoopBeats; beat++) {
                const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
                events.push({ time, note: beat % 4 === 0 ? 'C5' : 'C4', type: 'metro' });
            }

            events.sort((a, b) => Tone.Time(a.time).toSeconds() - Tone.Time(b.time).toSeconds());
            
            if (events.length > 0 && loopEndMeasures > 0) {
                const inputCells = Array.from(document.querySelectorAll('#input-grid input'));
                part = new Tone.Part((time, value) => {
                    if (value.type === 'bass') {
                        bassSynth.triggerAttackRelease(value.note, value.duration, time);
                    } else if (value.type === 'metro') {
                        metronome.triggerAttackRelease(value.note, '16n', time);
                    } else if (value.type === 'highlight') {
                        Tone.Draw.schedule(() => {
                            document.querySelectorAll('.input-grid-cell.cell-active').forEach(c => c.classList.remove('cell-active'));
                            if(inputCells[value.gridIndex]) {
                                inputCells[value.gridIndex].classList.add('cell-active');
                            }
                            updateNeckForPlayback(value.gridIndex);
                        }, time);
                    }
                }, events).start("1m");

                part.loop = true;
                part.loopEnd = `${loopEndMeasures}m`;
            }
        }
        
        // --- Analysis & Music Theory Functions ---

        function analyzeSingleChord(chordName, key, nextChordName) {
            const noteInfo = getNoteInfo(chordName);
            const quality = getChordQuality(chordName);
            const degree = findDegree(chordName, key);
            
            const isOutOfKey = checkIfOutOfKey(chordName, key, degree);
            const isPotentiallyDominant = (degree.replace(/[#b]/g, '').toUpperCase() === 'V');
            
            let isConfirmedDominant = false;
            if (isPotentiallyDominant) {
                const currentRootIndex = getNoteInfo(chordName).index;
                const nextRootIndex = getNoteInfo(nextChordName).index;
                if (currentRootIndex !== -1 && nextRootIndex !== -1 && (currentRootIndex - nextRootIndex + 12) % 12 === 7) {
                    isConfirmedDominant = true;
                }
            }

            let front;
            if (isConfirmedDominant) {
                front = 'TENSION';
            } else if (isOutOfKey) {
                front = 'OUT_OF_KEY';
            } else {
                front = 'R√âSOLUTION';
            }

            const actionRythmique = front === 'TENSION' || front === 'OUT_OF_KEY' ? 'RAPIDE / AGRESSIF' : 'LENT / LYRIQUE';
            
            let noteFondatrice = [];
            if (front === 'TENSION') {
                noteFondatrice.push({ note: getIntervalNote(noteInfo.root, 4, key), interval: '3M', type:'fondatrice' });
                noteFondatrice.push({ note: getIntervalNote(noteInfo.root, 10, key), interval: 'b7', type:'fondatrice' });
            } else {
                noteFondatrice.push({
                    note: getIntervalNote(noteInfo.root, quality.includes('minor') ? 3 : 4, key),
                    interval: quality.includes('minor') ? '3m' : '3M',
                    type: 'fondatrice'
                });
            }

            const expressivePalette = getExpressivePalette(front, noteInfo.root, key);
            const allTargetOptions = [...noteFondatrice, ...expressivePalette];

            return { 
                accord: chordName, 
                degre: degree,
                front,
                actionRythmique,
                allTargetOptions
            };
        }

        function getExpressivePalette(front, rootNote, key) {
            let palette = [];
            if (front === 'R√âSOLUTION') {
                palette = [
                    { note: getIntervalNote(rootNote, 2, key), interval: '9e', intention: 'Lyrisme / Douceur', description: '√âmotion : Doux, apaisant. Action : Id√©al pour les phrases longues et m√©lodiques.' },
                    { note: getIntervalNote(rootNote, 9, key), interval: '6M', intention: 'Funk / Optimisme', description: 'Couleur : √âclaircit le son mineur (Dorian). Action : Pour les plans rythm√©s et dansants.' },
                    { note: getIntervalNote(rootNote, 6, key), interval: '#11', intention: 'R√™veur / Flottant', description: 'Effet : Sensation a√©rienne et myst√©rieuse (Lydien). Action : √Ä utiliser sur des plans qui montent ou glissent.' }
                ];
            }
            if (front === 'TENSION' || front === 'OUT_OF_KEY') {
                 palette = [
                    { note: getIntervalNote(rootNote, 1, key), interval: 'b9', intention: 'Tension Ultime', description: '√âmotion : Choc et urgence. Action : √Ä r√©server au Climax. Force la r√©solution.' },
                    { note: getIntervalNote(rootNote, 3, key), interval: '#9', intention: 'Action / Hard Rock', description: 'Couleur : Puissante et agressive (Blues/Rock). Action : Pour les plans rythmiques rapides et percussifs.' },
                    { note: getIntervalNote(rootNote, 2, key), interval: '9M', intention: 'Couleur Solide / Stable', description: 'HYPERSTRUCTURE SOLIDE. Moins agressif que le Tritone. Donne un son riche et clair.' }
                ];
            }
            return palette.map(p => ({...p, type: 'expressive'}));
        }
        
        function checkIfOutOfKey(chordName, key, degree) {
            const scaleNotes = getScaleNotes(key);
            if (!scaleNotes.length) return false;
            const scaleNotesIndices = scaleNotes.map(n => getNoteInfo(n).index);
            const chordTonesNotes = getChordTones(chordName, key);

            for (const tone of chordTonesNotes) {
                const toneIndex = getNoteInfo(tone).index;
                if (!scaleNotesIndices.includes(toneIndex)) {
                    if (key.type === 'minor' && degree.toUpperCase().replace(/[#b]/g, '') === 'V') {
                         const harmonicMinorLeadingToneIndex = (getNoteInfo(key.root).index + 11) % 12;
                         if (toneIndex === harmonicMinorLeadingToneIndex) {
                             continue;
                         }
                    }
                    return true;
                }
            }
            return false;
        }

        // --- UI & Display Functions ---

        function createAnalysisCard(analysis) {
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'p-1 w-1/2 md:w-1/3 lg:w-1/4';

            let cardClass, badgeClass, badgeText;
            switch(analysis.front) {
                case 'TENSION': cardClass = 'card-tension'; badgeClass = 'badge-tension'; badgeText = 'TENSION'; break;
                case 'OUT_OF_KEY': cardClass = 'card-out-of-key'; badgeClass = 'badge-out-of-key'; badgeText = 'HORS TONALIT√â'; break;
                default: cardClass = 'card-resolution'; badgeClass = 'badge-resolution'; badgeText = 'R√âSOLUTION';
            }
            
            const targetOptionsHTML = analysis.allTargetOptions.map((item, index) => `
                <div>
                    <input type="radio" name="target-choice-${analysis.analysisIndex}" id="target-${analysis.analysisIndex}-${index}" value="${index}" class="target-choice-input">
                    <label for="target-${analysis.analysisIndex}-${index}" class="target-choice-label text-sm">
                        <span class="font-bold">${item.note} (${item.interval})</span> - <span class="text-gray-400">${item.intention || (item.interval.includes('3') ? 'Note Couleur' : 'Note Stabilit√©')}</span>
                    </label>
                </div>
            `).join('');

            cardWrapper.innerHTML = `
                <div class="card ${cardClass} rounded-lg p-2 flex flex-col h-full space-y-2">
                    <div class="flex-shrink-0">
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="text-lg font-extrabold text-white">${analysis.accord} <span class="text-base font-semibold text-gray-400">${analysis.degre}</span></h3>
                            <span class="badge info-badge ${badgeClass}" data-front="${analysis.front}">${badgeText}</span>
                        </div>
                         <p class="text-[11px] ${analysis.front === 'TENSION' || analysis.front === 'OUT_OF_KEY' ? 'text-rose-300' : 'text-blue-300'} font-semibold">${analysis.actionRythmique}</p>
                    </div>

                    <div class="flex-grow space-y-2">
                        <div>
                            <p class="text-[11px] text-violet-400 font-bold tracking-wider mb-1">CHOISIR UNE NOTE CIBLE</p>
                            <div class="space-y-1">${targetOptionsHTML}</div>
                        </div>
                    </div>
                </div>
            `;
            return cardWrapper;
        }
        
        function handleNoteSelection(event) {
            if (!event.target.matches('.target-choice-input')) return;

            const radio = event.target;
            const analysisIndex = parseInt(radio.name.split('-')[2], 10);
            const selectedItemIndex = parseInt(radio.value, 10);
            
            const analysis = analysisResultsForExport[analysisIndex];
            if (!analysis) return;

            analysis.selectedNote = analysis.allTargetOptions[selectedItemIndex];

            if (Tone.Transport.state !== 'started') {
                 updateNeckDisplay({ active: [analysis.selectedNote], preview: [] });
            }
        }
        
        function handleBadgeClick(event) {
            if (!event.target.matches('.info-badge')) return;
            
            const badge = event.target;
            const front = badge.dataset.front;
            let title, body;

            switch(front) {
                case 'TENSION':
                    title = 'Front de la Tension (Dominante)';
                    body = "Cet accord (V7 ou vii¬∞) force le mouvement vers la r√©solution. Votre jeu doit √™tre RAPIDE et AGRESSIF. C'est le moment d'acc√©l√©rer, d'utiliser des notes courtes et de cr√©er une attente.";
                    break;
                case 'OUT_OF_KEY':
                    title = 'Front de la Tension (Hors Tonalit√©)';
                    body = "Cet accord contient des notes √©trang√®res √† la gamme, cr√©ant un 'choc' harmonique. Il g√©n√®re une tension qui demande √† √™tre g√©r√©e. Consid√©rez-le comme une zone de jeu RAPIDE et SURPRENANTE.";
                    break;
                default:
                    title = 'Front de la R√©solution';
                    body = "Cet accord est une zone de repos, de transition ou de couleur. Votre jeu doit √™tre LENT et LYRIQUE. C'est le moment d'utiliser des phras√©s m√©lodiques et de laisser respirer la musique.";
            }
            showModal(title, body);
        }

        function showModal(title, body) {
            modalTitle.textContent = title;
            modalBody.textContent = body;
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.querySelector('#info-modal-overlay').classList.remove('opacity-0');
                modal.querySelector('#info-modal-content').classList.remove('opacity-0', 'scale-95');
                modal.querySelector('#info-modal-content').classList.add('opacity-100', 'scale-100');
            }, 10);
        }

        function hideModal() {
            const modal = document.getElementById('info-modal');
            modal.querySelector('#info-modal-overlay').classList.add('opacity-0');
            modal.querySelector('#info-modal-content').classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }


        function displayScaleNotes(key) {
            const scaleNotes = getScaleNotes(key);
            scaleNotesDisplay.innerHTML = '';
            const notesContainer = document.createElement('div');
            notesContainer.className = 'scale-notes-block';
            notesContainer.innerHTML = scaleNotes.map(note =>
                `<span class="${note === key.root ? 'root' : ''}">${note}</span>`
            ).join('');
            scaleNotesDisplay.appendChild(notesContainer);
        }

        // --- Music Theory Helper Functions ---

        function detectKey(firstChord) {
            const { root } = getNoteInfo(firstChord);
            const quality = getChordQuality(firstChord);
            const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
            const flatMinorKeys = ['Dm', 'Gm', 'Cm', 'Fm', 'Bbm', 'Ebm']; 
            
            let keySignatureType = 'sharp';
            if (flatKeys.includes(root) || flatMinorKeys.includes(root+'m') || root.includes('b')) {
                keySignatureType = 'flat';
            }

            if (quality.includes('minor')) {
                return { name: `${root} mineur`, root: root, type: 'minor', keySignatureType };
            }
            return { name: `${root} Majeur`, root: root, type: 'major', keySignatureType };
        }
        
        function getScaleNotes(key) {
            const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
            const intervals = key.type === 'major' ? MAJOR_SCALE_INTERVALS : [0, 2, 3, 5, 7, 8, 10]; // natural minor
            const rootIndex = getNoteInfo(key.root).index;
            if (rootIndex === -1) return [];
            return intervals.map(i => noteArray[(rootIndex + i) % 12]);
        }
        
        function getPentatonicScaleNotes(key) {
            const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
            const intervals = key.type === 'major' ? MAJOR_PENTATONIC_INTERVALS : MINOR_PENTATONIC_INTERVALS;
            const rootIndex = getNoteInfo(key.root).index;
            if (rootIndex === -1) return [];
            return intervals.map(i => noteArray[(rootIndex + i) % 12]);
        }


        function getChordTones(chordName, key) {
            const noteInfo = getNoteInfo(chordName);
            const quality = getChordQuality(chordName);
            if(noteInfo.index === -1) return [];
            const root = noteInfo.root;
            
            const thirdInterval = quality.includes('minor') || quality.includes('diminished') ? 3 : 4;
            const fifthInterval = quality.includes('diminished') ? 6 : 7;
            
            const third = getIntervalNote(root, thirdInterval, key);
            const fifth = getIntervalNote(root, fifthInterval, key);
            let tones = [root, third, fifth];

            if (quality.includes('7')) {
                let seventhInterval;
                if(quality === 'major7') seventhInterval = 11;
                else if (quality === 'diminished7') seventhInterval = 9;
                else seventhInterval = 10;
                const seventh = getIntervalNote(root, seventhInterval, key); 
                tones.push(seventh);
            }
            return tones;
        }

        function getNoteInfo(noteName) {
            if (!noteName || typeof noteName !== 'string') return { root: '?', index: -1 };
            
            const match = noteName.match(/^([A-G])([#b]?)/);
            if (!match) return { root: '?', index: -1 };
            
            const root = match[0];
            const sharpIndex = NOTES.sharp.indexOf(root);
            const flatIndex = NOTES.flat.indexOf(root);
            
            if (sharpIndex !== -1) return { root, index: sharpIndex };
            if (flatIndex !== -1) return { root, index: flatIndex };

            const equivalentFlat = convertToFlat(root);
            const index = NOTES.flat.indexOf(equivalentFlat);
            return { root, index };
        }

        function getChordQuality(chordName) {
            if (!chordName) return '';
            if (chordName.includes('maj7') || chordName.includes('M7') || chordName.includes('Œî')) return 'major7';
            if (chordName.includes('m7') || chordName.includes('min7')) return 'minor7';
            if (chordName.includes('¬∞7') || chordName.includes('dim7')) return 'diminished7';
            if (chordName.includes('dim') || chordName.includes('¬∞')) return 'diminished';
            if (chordName.includes('m') && !chordName.includes('maj')) return 'minor';
            if (chordName.includes('7')) return 'dominant7';
            return 'major';
        }

        function getIntervalNote(rootNote, semitones, key) {
            const rootInfo = getNoteInfo(rootNote);
            if (rootInfo.index === -1) return '?';
            const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
            const targetIndex = (rootInfo.index + semitones) % 12;
            return noteArray[targetIndex];
        }

        function convertToFlat(note) {
            const map = { 'A#': 'Bb', 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab' };
            return map[note] || note;
        }

        function findDegree(chordName, key) {
            const chordRootInfo = getNoteInfo(chordName);
            if(chordRootInfo.index === -1) return '?';
            const keyRootIndex = getNoteInfo(key.root).index;
            if (keyRootIndex === -1) return '?';

            const quality = getChordQuality(chordName);
            const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
            const interval = (chordRootInfo.index - keyRootIndex + 12) % 12;
            
            let degree = '?';
            let alteration = '';
            
            const referenceIntervals = MAJOR_SCALE_INTERVALS;

            for (let i = 0; i < referenceIntervals.length; i++) {
                const scaleInterval = referenceIntervals[i];
                if (interval === scaleInterval) { 
                    degree = romanNumerals[i]; 
                    break; 
                }
                if (interval === scaleInterval - 1) { 
                    alteration = 'b'; 
                    degree = romanNumerals[i]; 
                    break; 
                }
                if (i > 0 && interval === referenceIntervals[i-1] + 1) { 
                    if(interval === 3) continue; 
                    alteration = '#'; 
                    degree = romanNumerals[i-1]; 
                    break; 
                }
            }
            
            if (degree === '?') {
                 if (interval === 6) { alteration = '#'; degree = 'IV'; }
                 else { return '?'; }
            }

            if (quality.includes('minor')) {
                degree = degree.toLowerCase();
            } else if (quality.includes('diminished')) {
                degree = degree.toLowerCase() + '¬∞';
            }

            return alteration + degree;
        }

        // --- Utility Functions ---

        function clearGrid() {
            const inputs = document.querySelectorAll('#input-grid input');
            inputs.forEach(input => {
                input.value = '';
            });
            analyzeProgression();
            updatePlayer();
        }

        function generateRandomProgression() {
            clearGrid();
            const progressions = [
                { name: "Pop/Rock Mineur", chords: ['Am', '', 'G', '', 'D', '', 'E', ''] },
                { name: "Jazz ii-V-I (Majeur)", chords: ['Dm7', '', 'G7', '', 'Cmaj7', ''] },
                { name: "Pop/Rock Majeur", chords: ['C', '', 'G', '', 'Am', '', 'F', ''] },
                { name: "Blues 12 Mesures (en A)", chords: ['A7','','A7','','A7','','A7','','D7','','D7','','A7','','A7','','E7','','D7','','A7','','A7',''] }
            ];
            const randomProg = progressions[Math.floor(Math.random() * progressions.length)];
            const inputs = Array.from(document.querySelectorAll('#input-grid input'));
            randomProg.chords.forEach((chord, i) => {
                if (i < inputs.length) {
                    inputs[i].value = chord;
                }
            });
            analyzeProgression();
            updatePlayer();
        }

        function findLastIndex(arr, predicate) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (predicate(arr[i])) return i;
            }
            return -1;
        }
        
        function exportToCSV() {
            if (analysisResultsForExport.length === 0) return;

            const headers = ['Accord', 'Degr√©', 'Front GIA', 'Action Rythmique', 'Note(s) Fondatrice(s)', 'Intention Choisie', 'Note Expressive Choisie'];
            
            const rows = analysisResultsForExport.map(res => {
                if (!res.accord) return null;
                
                const fondatriceText = res.allTargetOptions.filter(i => i.type === 'fondatrice').map(item => `${item.note} (${item.interval})`).join(' & ');

                const row = [
                    `"${res.accord}"`, `"${res.degre}"`, `"${res.front}"`, `"${res.actionRythmique}"`, `"${fondatriceText}"`
                ];

                if (res.selectedNote && res.selectedNote.type === 'expressive') {
                    const item = res.selectedNote;
                    row.push(`"${item.intention}"`, `"${item.note} (${item.interval})"`);
                } else {
                    row.push('""', '""');
                }
                
                return row;
            }).filter(row => row !== null);

            let csvContent = "data:text/csv;charset=utf-8," 
                + headers.join(",") + "\n" 
                + rows.map(e => e.join(",")).join("\n");
            
            const link = document.createElement("a");
            link.setAttribute("href", encodeURI(csvContent));
            link.setAttribute("download", "analyse_gia_palette.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // --- Guitar Neck Functions ---

        function calculateNotePositions() {
            NOTES.sharp.forEach(note => notePositions[note] = []);
            NOTES.flat.forEach(note => notePositions[note] = []);

            for (let stringIndex = 0; stringIndex < 6; stringIndex++) {
                const openStringNote = TUNING[5 - stringIndex];
                let currentNoteIndex = getNoteInfo(openStringNote).index;
                for (let fret = 0; fret < 13; fret++) {
                    const noteNameSharp = NOTES.sharp[currentNoteIndex % 12];
                    const noteNameFlat = NOTES.flat[currentNoteIndex % 12];
                    
                    if (!notePositions[noteNameSharp]) notePositions[noteNameSharp] = [];
                    notePositions[noteNameSharp].push([stringIndex, fret]);
                    if (noteNameSharp !== noteNameFlat) {
                         if (!notePositions[noteNameFlat]) notePositions[noteNameFlat] = [];
                         notePositions[noteNameFlat].push([stringIndex, fret]);
                    }
                    currentNoteIndex++;
                }
            }
        }
        
       function drawNeck(pentatonicNotes = []) {
            neckSVG.innerHTML = '';
            const SVG_NS = "http://www.w3.org/2000/svg";
            const NUM_FRETS = 12;
            const NECK_WIDTH = 800;
            const NECK_HEIGHT = 140;

            const defs = document.createElementNS(SVG_NS, 'defs');
            const gradient = document.createElementNS(SVG_NS, 'linearGradient');
            gradient.setAttribute('id', 'woodGrain');
            gradient.setAttribute('x1', '0%'); gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '0%'); gradient.setAttribute('y2', '100%');
            gradient.innerHTML = `<stop offset="0%" style="stop-color:#6b4629;stop-opacity:1" /><stop offset="100%" style="stop-color:#4a2f19;stop-opacity:1" />`;
            defs.appendChild(gradient);
            neckSVG.appendChild(defs);
            
            const fretboard = document.createElementNS(SVG_NS, 'rect');
            fretboard.setAttribute('x', 0); fretboard.setAttribute('y', 0);
            fretboard.setAttribute('width', NECK_WIDTH + 50); fretboard.setAttribute('height', NECK_HEIGHT);
            fretboard.setAttribute('fill', 'url(#woodGrain)');
            neckSVG.appendChild(fretboard);
            
            const scaleNotesGroup = document.createElementNS(SVG_NS, 'g');
            scaleNotesGroup.setAttribute('id', 'scale-notes-layer');
            neckSVG.appendChild(scaleNotesGroup);

            pentatonicNotes.forEach(note => {
                const positions = notePositions[note] || [];
                positions.forEach(([string, fret]) => {
                    if (fret > NUM_FRETS) return;
                    const circle = document.createElementNS(SVG_NS, 'circle');
                    const y = (NECK_HEIGHT / 12) * (string * 2 + 1);
                    const x = 50 + ((fret - 0.5) * (NECK_WIDTH / (NUM_FRETS + 1)));
                    
                    circle.setAttribute('cx', fret === 0 ? 25 : x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 10);
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', '#6B7280');
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('opacity', '0.6');
                    scaleNotesGroup.appendChild(circle);
                });
            });


            for(let i = 0; i <= NUM_FRETS + 1; i++) {
                const fret = document.createElementNS(SVG_NS, 'line');
                const x = 50 + (i * (NECK_WIDTH / (NUM_FRETS+1)));
                fret.setAttribute('x1', x); fret.setAttribute('y1', 0);
                fret.setAttribute('x2', x); fret.setAttribute('y2', NECK_HEIGHT);
                fret.setAttribute('stroke', i === 0 ? '#e5e7eb' : '#a0a0a0');
                fret.setAttribute('stroke-width', i === 0 ? '6' : '3');
                neckSVG.appendChild(fret);
            }

            for(let i=0; i<6; i++) {
                const string = document.createElementNS(SVG_NS, 'line');
                const y = (NECK_HEIGHT / 12) * (i * 2 + 1);
                string.setAttribute('x1', 50); string.setAttribute('y1', y);
                string.setAttribute('x2', NECK_WIDTH + 50); string.setAttribute('y2', y);
                string.setAttribute('stroke', '#cbd5e1');
                string.setAttribute('stroke-width', 1 + (i * 0.2));
                neckSVG.appendChild(string);
            }

            const markers = { 3:1, 5:1, 7:1, 9:1, 12:2 };
            for (const [fret, num] of Object.entries(markers)) {
                 const x = 50 + ((fret-0.5) * (NECK_WIDTH / (NUM_FRETS+1)));
                if (num === 1) {
                    const marker = document.createElementNS(SVG_NS, 'circle');
                    marker.setAttribute('cx', x); marker.setAttribute('cy', NECK_HEIGHT / 2);
                    marker.setAttribute('r', 5); marker.setAttribute('fill', '#e5e7eb'); marker.setAttribute('opacity', '0.2');
                    neckSVG.appendChild(marker);
                } else {
                    [NECK_HEIGHT / 4, (NECK_HEIGHT / 4) * 3].forEach(y => {
                        const marker = document.createElementNS(SVG_NS, 'circle');
                        marker.setAttribute('cx', x); marker.setAttribute('cy', y);
                        marker.setAttribute('r', 5); marker.setAttribute('fill', '#e5e7eb'); marker.setAttribute('opacity', '0.2');
                        neckSVG.appendChild(marker);
                    });
                }
            }
             const targetNotesGroup = document.createElementNS(SVG_NS, 'g');
             targetNotesGroup.setAttribute('id', 'target-notes-layer');
             neckSVG.appendChild(targetNotesGroup);
        }
        
        function updateNeckForPlayback(gridIndex) {
            // Find the analysis for the chord that is currently "active" by looking backwards from the current grid cell
            let currentAnalysis = null;
            for (let i = gridIndex; i >= 0; i--) {
                const analysis = analysisResultsForExport.find(a => a.gridIndex === i);
                if (analysis) {
                    currentAnalysis = analysis;
                    break;
                }
            }

            // If there's no current chord (e.g., grid starts with empty cells), do nothing.
            if (!currentAnalysis) {
                updateNeckDisplay({ active: [], preview: [] });
                return;
            }
            
            // Find the *next* analysis in the sequence using the ordered analysisResultsForExport array
            const currentAnalysisOrderIndex = currentAnalysis.analysisIndex;
            let nextAnalysis = analysisResultsForExport[currentAnalysisOrderIndex + 1];

            // If we're on the last chord, the next one is the first one (looping)
            if (!nextAnalysis) {
                nextAnalysis = analysisResultsForExport[0];
            }

            let activeNotes = [];
            if (currentAnalysis && currentAnalysis.selectedNote) {
                activeNotes.push({ ...currentAnalysis.selectedNote });
            }

            let previewNotes = [];
            if (nextAnalysis && nextAnalysis.selectedNote) {
                previewNotes.push({ ...nextAnalysis.selectedNote });
            }
            
            updateNeckDisplay({ active: activeNotes, preview: previewNotes });
        }


        function updateNeckDisplay(notes) {
            const targetNotesGroup = document.getElementById('target-notes-layer');
            if (!targetNotesGroup) return;
            targetNotesGroup.innerHTML = '';

            const NUM_FRETS = 12;
            const NECK_WIDTH = 800;
            const NECK_HEIGHT = 140;
            const SVG_NS = "http://www.w3.org/2000/svg";

            const colors = {
                fondatrice: '#10B981', 
                expressive: '#8B5CF6',
                preview: '#FBBF24' // Amber
            };

            // Preview note (upcoming, selected, solid, not animated)
            notes.preview.forEach(noteItem => {
                const positions = notePositions[noteItem.note] || [];
                positions.forEach(([stringIndex, fret]) => {
                    if (fret > NUM_FRETS) return;
                    
                    const dot = document.createElementNS(SVG_NS, 'circle');
                    const y = (NECK_HEIGHT / 12) * (stringIndex * 2 + 1);
                    const x = 50 + ((fret - 0.5) * (NECK_WIDTH / (NUM_FRETS + 1)));
                    
                    dot.setAttribute('cx', fret === 0 ? 25 : x);
                    dot.setAttribute('cy', y);
                    dot.setAttribute('r', 9);
                    dot.setAttribute('fill', colors.preview);
                    dot.setAttribute('class', 'note-dot');
                    
                    targetNotesGroup.appendChild(dot);
                });
            });
            
            // Active note (current, selected, solid, animated)
            notes.active.forEach(noteItem => {
                const positions = notePositions[noteItem.note] || [];
                positions.forEach(([stringIndex, fret]) => {
                    if (fret > NUM_FRETS) return;
                    
                    const dot = document.createElementNS(SVG_NS, 'circle');
                    const y = (NECK_HEIGHT / 12) * (stringIndex * 2 + 1);
                    const x = 50 + ((fret - 0.5) * (NECK_WIDTH / (NUM_FRETS + 1)));
                    
                    dot.setAttribute('cx', fret === 0 ? 25 : x);
                    dot.setAttribute('cy', y);
                    dot.setAttribute('fill', colors[noteItem.type] || '#FFFFFF');
                    dot.setAttribute('stroke', '#111827');
                    dot.setAttribute('class', 'note-dot note-dot-active');
                    
                    targetNotesGroup.appendChild(dot);
                });
            });
        }


        // --- Auto-run on load ---
        window.onload = () => {
            initializeApp();
            analyzeProgression();
            updatePlayer();
        };

    </script>
</body>
</html>

